# 백준 11659번 - 제목

[문제 보러 가기](https://www.acmicpc.net/problem/11659)

## 요약

M개의 줄에 입력으로 주어진 i번째 수 부터, j번째 수 까지의 합을 출력.

## 핵심 규칙

- 첫째 줄, 수의 개수 N과, 합을 구해야 하는 횟수 M이 주어진다.
- 둘째 줄, N개의 수가 주어진다.
- 셋째 줄부터 M개의 줄에는 합을 구해야 하는 구간 i와 j가 주어진다.
- i번째 수 부터, j번째 수 까지 합을 출력한다.
- 1 ≤ N ≤ 100,000 / 1 ≤ M ≤ 100,000 / 1 ≤ i ≤ j ≤ N

## 예제 입출력

입력 및 출력 예시는 [문제 링크](https://www.acmicpc.net/problem/11659) 참고.

## 문제풀이

`1. 예시`

``` TEXT
5 3
5 4 3 2 1
1 3
2 4
5 5
```

위에 입력이 입력된 경우, 5, 4, 3, 2, 1이 N개의 수로 주어진다.
i = 1, j = 3인 경우 5 + 4 + 3 = 12  
i = 2, j = 4인 경우 4 + 3 + 2 = 9  
i = 5, j = 5인 경우 1 = 1  

for문 또는 sum과 list 슬라이스 -> 시간초과

`2. 시간초과 문제풀이`

현재 상황에서 발생하는 시간 초과를 줄이는 방법은 for문을 적게 도는 것 뿐

그렇다면, 모든 결과를 모은 list를 생성하고, list에서 값을 꺼내는 형태로 수행하는 게 더 낫다.

즉, `dp[i][j]`는 i부터 j까지의 수의 합을 가지고 있도록 설정

``` TEXT
dp = 
    [5, 9, 12, 14, 15],
    [0, 4, 7, 9, 10],
    [0, 0, 3, 5, 6],
    [0, 0, 0, 2, 3],
    [0, 0, 0, 0, 1]
```

`3. 메모리 초과`

``` TEXT
n, m = map(int, input().split())
numbers = list(map(int, input().split()))
dp = [([0] * n) for _ in range(n)]
ans = 0
for k in range(n):
    ans += numbers[k]
    dp[0][k] = ans
for i in range(1, n):
    for j in range(i, n):
        dp[i][j] = dp[i-1][j] - numbers[i-1]
# print(dp)
for _ in range(m):
    ans = 0
    i, j = map(int, input().split())
    print(dp[i-1][j-1])
```

코드를 위 처럼 짠 경우, 메모리 초과가 발생
왜? -> dp를 따로 둔게 문제가 아닌가..  
해결방법은? -> 위의 dp를 보면, 0으로 설정된 빈 공간이 많다.  

더 작은 메모리를 사용해 해결할 방법은..?

numbers를 순차적인 값의 합으로 설정하자. 그리고 앞에 0을 붙이자.
즉, 위 예시대로 하면 numbers = [0, 5, 9, 12, 14, 15]가 된다.

i == j인 경우에는 numbers[j] - numbers[i-1]을 수행하면?
i = 1인 경우 5 - 0 = 5
i = 2인 경우 9 - 5 = 4...

i < j인 경우에는?
i = 1, j = 5인 경우 numbers[j] - numbers[i-1]
i = 2, j = 4인 경우 numbers[j] - numbers[i-1] = 14 - 5 = 9

왜? -> numbers[i]는 첫번째 수 부터, i까지의 수의 합이다.

i, j까지의 수의 합은 1부터 j까지의 합 - 1부터 i-1까지의 합이다.