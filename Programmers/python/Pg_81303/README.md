# 81303 표 편집

## 문제 설명

- 한 번에 한 행만 선택할 수 있고, 표의 범위를 벗어날 수 없다.
- 다음과 같은 명령어를 이용하여 표를 편집한다.

```Text
"U X": 현재 선택된 행에서 X칸 위에 있는 행을 선택합니다.

"D X": 현재 선택된 행에서 X칸 아래에 있는 행을 선택합니다.

"C" : 현재 선택된 행을 삭제한 후, 바로 아래 행을 선택합니다. 단, 삭제된 행이 가장 마지막 행인 경우 바로 윗 행을 선택합니다.

"Z" : 가장 최근에 삭제된 행을 원래대로 복구합니다. 단, 현재 선택된 행은 바뀌지 않습니다.
```

- 처음 표의 행 개수를 나타내는 정수 n, 처음에 선택된 행의 위치를 나타내는 정수 k, 수행한 명령어들이 담긴 문자열 배열 cmd가 매개변수로 주어짐.
- 모든 명령어를 수행한 후 표의 상태와 처음 주어진 표의 상태를 비교하여 삭제되지 않은 행은 O, 삭제된 행은 X로 표시하여 문자열 형태로 return 하도록 solution 함수를 완성.

## 제한 조건
- 5 ≤ n ≤ 1,000,000
- 0 ≤ k < n
- 1 ≤ cmd의 원소 개수 ≤ 200,000
  - cmd의 각 원소는 "U X", "D X", "C", "Z" 중 하나입니다.
  - X는 1 이상 300,000 이하인 자연수이며 0으로 시작하지 않습니다.
  - X가 나타내는 자연수에 ',' 는 주어지지 않습니다. 예를 들어 123,456의 경우 123456으로 주어집니다.
  - cmd에 등장하는 모든 X들의 값을 합친 결과가 1,000,000 이하인 경우만 입력으로 주어집니다.
  - 표의 모든 행을 제거하여, 행이 하나도 남지 않는 경우는 입력으로 주어지지 않습니다.
  - 본문에서 각 행이 제거되고 복구되는 과정을 보다 자연스럽게 보이기 위해 "이름" 열을 사용하였으나, "이름"열의 내용이 실제 문제를 푸는 과정에 필요하지는 않습니다. "이름"열에는 서로 다른 이름들이 중복없이 채워져 있다고 가정하고 문제를 해결해 주세요.
- 표의 범위를 벗어나는 이동은 입력으로 주어지지 않습니다.
- 원래대로 복구할 행이 없을 때(즉, 삭제된 행이 없을 때) "Z"가 명령어로 주어지는 경우는 없습니다.
- 정답은 표의 0행부터 `n - 1`행까지에 해당되는 O, X를 순서대로 이어붙인 문자열 형태로 return 해주세요.

## 정확성 테스트 케이스 제한 사항

- 5 ≤ n ≤ 1,000
- 1 ≤ cmd의 원소 개수 ≤ 1,000

## 입출력 예시
1. 
- n = 8	
- k = 2 	
- cmd = ["D 2","C","U 3","C","D 4","C","U 2","Z","Z"]
- result = "OOOOXOOO"

2. 
- n = 8	
- k = 2	
- cmd = ["D 2","C","U 3","C","D 4","C","U 2","Z","Z","U 1","C"]
- result = "OOXOXOOO"

### 문제 풀이
`1. 설계`
- 실제 주어진 문제의 경우, 행 별 이름이 주어진다 하는 문제는 없으므로, n크기의 배열을 선택하고, k의 위치를 cursor가 가리키도록 설정

- cursor는 실제로 D, U 등의 명령어에 의해 이동하면 됨

- 정확성 테스트와, 효율성 테스트에 의해 실행 시간을 따져보아야 함

- Z에 의해 가장 최근에 삭제된 행을 원래대로 복구해야 하므로, 삭제된 행의 순서를 저장해야 함

`2. 수정`
- 정확성, 효율성 모두 실패
- 알맞은 답을 찾는것 부터 문제
- 테스트케이스 생성하고 잘못된 부분 확인

```Text
표의 범위를 벗어나는 이동은 입력으로 주어지지 않습니다.
원래대로 복구할 행이 없을 때(즉, 삭제된 행이 없을 때) "Z"가 명령어로 주어지는 경우는 없습니다.
```
- 위 두 조건이 있으므로, 런타임 에러가 나올 가능성은 cursor가 표의 범위를 벗어나는 경우
- 반례를 찾고 싶었으나, 런타임에러는 어디서 나오는지 도저히 알 수 없음..

`3. 자료구조 변경`
- 사실 기존 풀이는 리스트를 활용, 고민을 조금만 해 봐도 이동을 하는 경우에 false로 처리가 된 모든 값을 확인한다는 부분이 엄청난 손해임을 느낌
- 그러면 뭘 써야하나?
- 이에 대한 해결은 자료구조로 가능
- 노드가 연결되어있는 경우라면, false처리가 된 경우 연결을 변경시키면 되고 다시 복구해야하는 경우는 다음을 가리키는 포인터를 다시 바꾸면 됨
- 그렇다면 파이썬에서 연결 리스트는 어떻게 쓰는가

```Text
class Linked_Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None
```

data는 노드의 상태, prev와 next는 이전, 다음 노드를 가리키도록 설계
처음에는 Linked_Node(1) for _ in range(n)을 활용하여 모든 노드가 살아있도록 설계
for 문을 돌면서 노드들이 서로 연결되게 설정하고, 조건에 맞게 solution 내부 조건을 변경

마지막에는 `''.join('O' if node.data == 1 else 'X' for node in nodes)`코드로
nodes 내부 노드들의 data 상태 유무에 따라 O또는 X를 answer에 추가하도록 설정