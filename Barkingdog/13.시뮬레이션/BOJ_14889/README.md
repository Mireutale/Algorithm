# 백준 14889번 - 스타트와 링크

[문제 보러 가기](https://www.acmicpc.net/problem/14889)

## 요약

- 축구를 하기 위해 모인 사람은 총 N명이고 신기하게도 N은 짝수
- 능력치 Sij는 i번 사람과 j번 사람이 같은 팀에 속했을 때, 팀에 더해지는 능력치이다.
- 팀의 능력치는 팀에 속한 모든 쌍의 능력치 Sij의 합이다.
- Sij는 Sji와 다를 수도 있으며, i번 사람과 j번 사람이 같은 팀에 속했을 때, 팀에 더해지는 능력치는 Sij와 Sji이다.

- 스타트 팀의 능력치와 링크 팀의 능력치의 차이를 최소

## 핵심 규칙

> 입력
>
> > 첫째 줄에 N(4 ≤ N ≤ 20, N은 짝수)이 주어진다.
> > 둘째 줄부터 N개의 줄에 S가 주어진다.
> > 각 줄은 N개의 수로 이루어져 있고, i번 줄의 j번째 수는 Sij 이다.
> > Sii는 항상 0이고, 나머지 Sij는 1보다 크거나 같고, 100보다 작거나 같은 정수이다.

> 출력
>
> > 첫째 줄에 스타트 팀과 링크 팀의 능력치의 차이의 최솟값을 출력한다

## 예제 입출력

입력 및 출력 예시는 [문제 링크](https://www.acmicpc.net/problem/14889) 참고.

### 문제풀이

`1.설계`

select에 1부터 n까지의 사람들 중에서 절반 인원을 뽑는 조합을 선택

뽑은 인원들에 대해서, start와 link팀을 나누고, start, link팀별로 다시 2명씩 선택 뽑은 인원들의 능력치를 모두 합한다음, 이전의 gap과 비교해서 더 작은 값을 선택

문제는 풀었는데.. 시간 차이가 꽤나 많이난다??

`2.리팩토링`

정답자분의 풀이를 보니 정말 신박했다...

스타트팀과 링크팀은 반드시 모든 능력치가 각 팀에 배정되어야 하고, 그 중에서 gap이 가장 작은 경우를 찾는게 문제이다.

status와 reverse\*status를 찾고 두 값을 더하면, i와 j가 팀에 들어가는 경우가 있으면 $S_{ij}$ + $S_{ji}$가 성립함

이를 통해서 `ns = [sum(status[i]) + sum(reverse_status[i]) for i in range(n)]`가 성립

이후 total을 `sum(ns) // 2`로 설정 왜냐하면, s[i][j]가 전부 중복해서 한번 더 들어가기 때문

사실상 total은 sum(s[:])와 동일

이제 (ns[:-1], n//2)를 가지고 조건을 만듬.

ns[:-1]을 통해서, 생성되는 조합중 마지막 인원은 무조건 링크팀에 들어가게 되고, 즉, 중복이 삭제됨

이제 선택한 조합과 total과의 차이를 diff로 두고, 만약 diff 가 ans보다 작으면 ans를 수정함

여기서 중요한게 팀의 시너지 계산값은 i, j가 있는 경우인데, 생각해보면 ns의 값은 중복이 있어서 제대로 계산이 안될 것이라는 생각이 든다.

그러나 자세히 살펴보자, A에서 0, 1이 B에서 2, 3인원이 있는 경우 total은 s01 + s10, s23 + s32는 당연히 포함하고, 남는 값 -> 0과2, 0과 3, 1과 2, 1과 3도 포함하게 된다.

그러면 ns는?

0과 1이 선택된 결과를 보자, 예시 1을 보면 ns[0] = 20, ns[1] = 21인데, 여기서 ns[0]은 s(01, 02, 03, 10, 30, 20)을 전부 가지고, ns[1]은 s(10, 12, 13, 01, 21, 31)을 가지게 된다.

이 경우에서 우리가 필요한 값은 s01, s10 두개의 값인데, s01, s10은 2개를 가지고, 나머지는 필요없는 값을 가지는 거다.

즉, total = A내부 + B내부 + A-B에 포함되지 않는 값

comb는 = 2\*A내부 + A-B에 포함되지 않는 값이 된다.

total - comb를 수행하면? B내부 - A내부 즉, 우리가 구하고 싶은 차이가 되는 것.
