# 백준 21610번 - 마법사 상어와 비바라기

[문제 보러 가기](https://www.acmicpc.net/problem/21610)

## 요약

크기가 $N \times N$인 격자에서 비바라기 사용  
격자의 각 칸에는 바구니가 하나 있고, 바구니는 칸 전체를 차지  
바구니에 저장할 수 있는 물의 양에는 제한이 없다.  
$(r, c)$는 격자의 r행 c열에 있는 바구니를 의미하고, $A[r][c]$는 $(r, c)$에 있는 바구니에 저장된 물의 양을 의미한다.

가장 왼쪽 윗 칸은 $(1, 1)$이고, 가장 오른쪽 아랫 칸은 $(N, N)$이다.

마법사 상어는 연습을 위해 1번 행, 열과 N번 행, 열을 연결했다.

비바라기를 시전하면 $(N, 1), (N, 2), (N-1, 1), (N-1, 2)$에 비구름이 생긴다.

구름에 M번 이동을 명령하려고 할때, i번째 이동 명령은 방향 $d_i$와 거리 $S_i$로 이루어져 있다.

방향은 총 8개의 방향이 있으며, 8개의 정수로 표현한다. 1부터 순서대로 ←, ↖, ↑, ↗, →, ↘, ↓, ↙ 이다.

1. 모든 구름이 di 방향으로 si칸 이동한다.
2. 각 구름에서 비가 내려 구름이 있는 칸의 바구니에 저장된 물의 양이 1 증가한다.
3. 구름이 모두 사라진다.
4. 2에서 물이 증가한 칸 (r, c)에 물복사버그 마법을 시전한다. 물복사버그 마법을 사용하면, 대각선 방향으로 거리가 1인 칸에 물이 있는 바구니의 수만큼 (r, c)에 있는 바구니의 물이 양이 증가한다.

   - 이때는 이동과 다르게 경계를 넘어가는 칸은 대각선 방향으로 거리가 1인 칸이 아니다.
   - 예를 들어, (N, 2)에서 인접한 대각선 칸은 (N-1, 1), (N-1, 3)이고, (N, N)에서 인접한 대각선 칸은 (N-1, N-1)뿐이다.

5. 바구니에 저장된 물의 양이 2 이상인 모든 칸에 구름이 생기고, 물의 양이 2 줄어든다. 이때 구름이 생기는 칸은 3에서 구름이 사라진 칸이 아니어야 한다.

M번의 이동이 모두 끝난 후 바구니에 들어있는 물의 양의 합을 구해보자.

## 핵심 규칙

> 입력
>
> > 첫째 줄에 N, M이 주어진다.  
> > 둘째 줄부터 N개의 줄에는 N개의 정수가 주어진다.  
> > r번째 행의 c번째 정수는 A[r][c]를 의미한다.  
> > 다음 M개의 줄에는 이동의 정보 di, si가 순서대로 한 줄에 하나씩 주어진다.

> 출력
>
> > 첫째 줄에 M번의 이동이 모두 끝난 후 바구니에 들어있는 물의 양의 합을 출력한다.

> 제한
>
> > 2 ≤ N ≤ 50  
> > 1 ≤ M ≤ 100  
> > 0 ≤ A[r][c] ≤ 100  
> > 1 ≤ di ≤ 8  
> > 1 ≤ si ≤ 50

## 예제 입출력

입력 및 출력 예시는 [문제 링크](https://www.acmicpc.net/problem/21610) 참고.

### 문제풀이

`1. 예시`

입력

```Text
5 4
0 0 1 0 2
2 3 2 1 0
4 3 2 9 0
1 0 2 9 0
8 8 2 1 0
1 3
3 4
8 1
4 8
```

- 아래는 현재 들어있는 물의 양이고 \*로 구름의 위치를 표시하였다.

```Text
0	0	1	0	2
2	3	2	1	0
4	3	2	9	0
*1	*0	2	9	0
*8	*8	2	1	0
```

1, 3이 입력 되었으므로 1번 방향(←)으로 3칸 이동해야 한다.

```Text
0	0	1	0	2
2	3	2	1	0
4	3	2	9	0
1	0	*2	*9	0
8	8	*2	*1	0
```

구름이 있는 칸이 비가 1 내리고, 구름은 사라진다. 사라진 구름은 -로 표시하였다.

```Text
0	0	1	0	2
2	3	2	1	0
4	3	2	9	0
1	0	-3	-10	0
8	8	-3	-2	0
```

- (4, 3)은 대각선 4개의 방향 모두에 물이 있다. 따라서, 물의 양이 4 증가해 7이 된다.
- (4, 4)는 대각선 2개의 방향(↖, ↙)에 물이 있다. 물의 양은 2 증가하고, 12가 된다.
- (5, 3)은 대각선으로 거리가 1인 칸이 2개(↖, ↗)있고, 이 중에서 1개(↗)만 물이 있다. 따라서, 물의 양은 3에서 4로 변한다.
- (5, 4)도 방향 1개(↖)만 물이 있기 때문에, 물의 양이 3이 된다.

```Text
0	0	1	0	2
2	3	2	1	0
4	3	2	9	0
1	0	7	12	0
8	8	4	3	0
```

- 이제 구름이 있었던 칸을 제외한 나머지 칸 중에서 물의 양이 2 이상인 칸에 구름이 생긴다.
- 구름이 생기면 물의 양이 2만큼 줄어든다.

```Text
0	0	1	0	0
0	1	0	1	0
2	1	0	7	0
1	0	7	12	0
6	6	4	3	0
```

- 두 번째 이동이 끝난 후의 상태는 다음과 같다.

```Text
2	1	1	0	0
0	1	0	1	2
5	4	5	5	0
4	5	12	15	0
4	4	2	1	0
```

- 다음은 세 번째 이동이 끝난 후의 상태이다.

```Text
4	2	4	0	2
0	1	0	1	0
3	2	3	3	0
2	3	17	13	0
2	2	0	1	0
```

- 모든 이동이 끝난 최종 상태는 다음과 같다.

```Text
2	4	2	2	4
3	1	0	5	3
1	0	1	1	0
0	1	22	11	0
4	5	0	3	2
```

- 먼저 문제를 풀기 위해서 기본적으로 board에 현 상태를 저장해야 한다.
- 그리고 Move에 어떻게 이동할 것인지를 저장하고, direction을 미리 저장해 놓는다.
- Cloud에 미리 구름을 저장해 놓을 것이고, 물복사 버그 수행 후 물 양을 줄이고 temp에 새로운 구름을 저장해야 하는데, 이전 cloud와 동일한 위치는 사용하지 않는걸로 한다.

`2. 시간초과`
"""Text
if **name** == "**main**":

   N, M = map(int, input().split())
   board = [] # 기존의 땅 상황
   move = deque() # 구름의 이동
   cloud = deque([[N-1, 0], [N-1, 1], [N-2, 0], [N-2, 1]])

   for _ in range(N):
      board.append(list(map(int ,input().split())))

   for _ in range(M):
      move.append(list(map(int, input().split()))) # 8개 방향 : ←(9시), ↖(11시), ↑(12시), ↗(1시), →(3시), ↘(5시), ↓(6시), ↙(7시)
      direction = [(0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1)]
      diagonal = [(-1, -1), (-1, 1), (1, -1), (1, 1)]

   while move:
      direct, move*times = move.popleft()
      for * in range(len(cloud)):
         x, y = cloud.popleft()
         dx, dy = direction[direct-1]
         nx, ny = x + (dx _ move_times), y + (dy _ move_times)
         cloud.append([nx % N, ny % N])

        for i, j in cloud:
            board[i][j] += 1
            for k, l in diagonal:
                di, dj = i + k, j + l
                if 0 <= di < N and 0 <= dj < N:
                    if board[di][dj] != 0 or [di, dj] in cloud:
                        board[i][j] += 1

        temp = deque()
        for i in range(N):
            for j in range(N):
                if [i, j] not in cloud:
                    if board[i][j] >= 2:
                        board[i][j] -= 2
                        temp.append([i, j])
        cloud = temp

    ans = 0
    for i in range(N):
        ans += sum(board[i])
    print(ans)

"""

- 기존 코드를 보면 for 반복문을 여러번 중첩해서 사용하는 부분이 많이 나온다.

- 개선사항
```
1. dx, dy를 매 반복마다 구할 이유는 없음
2. 구름의 이동을 생각해보면, s칸 이동한다고 할때, `s%N`칸 이동과 결과가 동일
   - 이를 통해서 nx, ny가 너무 큰 수가 되었다가 나머지 연산을 하는것을 방지
3. before_cloud라는 리스트에 `before_cloud[i][j]`의 형식으로 이전의 구름을 찾는것이 더 유리
   - 기존에는 [i, j]라는 리스트를 cloud에서 찾으려고 했기 때문에, 시간이 더 오래 걸리는 것
   - 이를 단순 인덱싱으로 변경하여 복잡도를 줄임
   - set을 활용하는 것도 생각했음 -> 그러나 덱과, 해싱 및 튜플로 변경하는 과정이 더 불필요하다고 판단
```