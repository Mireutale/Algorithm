# 백준 1629번 - 곱셈

[문제 보러 가기](https://www.acmicpc.net/problem/1629)

## 요약

자연수 A를 B번 곱한 수를 알고 싶다.
구하려는 수가 매우 커질 수 있으므로, 이를 C로 나눈 나머지를 구하는 프로그램을 작성

## 핵심 규칙

- 첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. 
- A, B, C는 모두 2,147,483,647 이하의 자연수이다.
- 첫째 줄에 A를 B번 곱한 수를 C로 나눈 나머지를 출력한다

## 예제 입출력

입력 및 출력 예시는 [문제 링크](https://www.acmicpc.net/problem/1629) 참고.

### 문제풀이

`1. 관찰`
10 11 12

반복해서 10을 곱하고, 10을 11번 곱한뒤 그 값에 12로 나눈 나머지를 출력하면 된다.

10을 두번 곱하면 100.

100을 12로 나누면 4
40을 12로 나누면 4
1000을 12로 나누면? 4

a = b*c + d일때
a**2 = ab*c + a*d가 되고, a * d로 다시 나머지를 구하면 된다.

`2.메모리 초과, 시간 초과`
재귀 횟수를 늘려서 수행시 메모리 초과가 발생한다.
for 문으로 곱하고 나누기를 반복하면 시간 초과가 발생한다.

`3, 다른 풀이`

우리가 구하고자 하는 값은 (A ** B) % C이다.

B가 짝수인 경우 (A**B)%C == ((A**(B/2)) % C) * ((A**(B/2)) % C) % C
B가 홀수인 경우 (A**B)%C == ((A**(B//2)) % C) * ((A**(B//2)) % C) * (A % C) % C이다.

두가지 경우로 나눠서 값을 구해보자.

`4.반복문`

재귀 말고 반복문으로 푸는 방법도 존재한다.

b를 이진수로 보는게 핵심이다.

b가 11인경우 이진수로 보면 b는 1011이 된다.

이때, 11은 2**3 * 2**1 * 2**0과 동일하다.
즉, 2**3, 2**1, 2**0으로 나누어서 다 곱하면 정답이라는 뜻이다.

먼저 a %= c를 하는 이유는 모듈러 연산에 있다.

a ** b mod c는 (a mod c)**b mod c와 동일하다.
그러므로 a mod c를 먼저해주면 a ** 2를 수행할 때, 값의 크기를 줄일 수 있으므로 미리 수행해주는게 좋다.

이제 반복문을 보면, b % 2 == 1일때, 즉 가장 오른쪽 비트가 1일 때만 result에 값을 곱해준다.

이후, b = b // 2로 이미 사용한 가장 오른쪽 비트는 제한다.
이 과정에서, a = a ** 2 % c로 계속해서 바꿔준다.
이렇게 해야, 가장 오른쪽 비트가 1일때, 계산이 정확하게 된다.