# 백준 18809번 - Gaaaaaaaaaarden

[문제 보러 가기](https://www.acmicpc.net/problem/18809)

## 요약

- 호수, 배양액을 뿌릴 수 있는 땅, 배양액을 뿌릴 수 없는 땅으로 나뉜다.
- 배양액은 매 초마다 이전에 배양액이 도달한 적이 없는 인접한 땅으로 퍼져간다.
- 초록색 배양액과 빨간색 배양액이 동시에 도달한 땅에서는 꽃이 피어난다.
  - 꽃이 피어나는 경우 더이상 인접한 땅으로 배양액을 퍼트리지 않는다.
- 모든 배양액을 남김없이 사용해야 하며, 서로 다른곳에 뿌려져야할때 피울 수 있는 꽃의 최대 개수를 구해보자.

## 핵심 규칙

> 입력
>
> > 첫째 줄에 정원의 행의 개수와 열의 개수를 나타내는 N(2 ≤ N ≤ 50)과 M(2 ≤ M ≤ 50), 그리고 초록색 배양액의 개수 G(1 ≤ G ≤ 5)와 빨간색 배양액의 개수 R(1 ≤ R ≤ 5)이 한 칸의 빈칸을 사이에 두고 주어진다.  
> > 그 다음 N개의 줄에는 각 줄마다 정원의 각 행을 나타내는 M개의 정수가 한 개의 빈 칸을 사이에 두고 주어진다.  
> > 각 칸에 들어가는 값은 0, 1, 2이다. 0은 호수, 1은 배양액을 뿌릴 수 없는 땅, 2는 배양액을 뿌릴 수 있는 땅을 의미한다.  
> > 배양액을 뿌릴 수 있는 땅의 수는 R+G개 이상이고 10개 이하이다.

> 출력
>
> > 첫째 줄에 피울 수 있는 꽃의 최대 개수를 출력한다.

## 예제 입출력

입력 및 출력 예시는 [문제 링크](https://www.acmicpc.net/problem/18809) 참고.

### 문제풀이

`1.설계`

1. garden에 row를 N개 입력하면서, row중에서 2인 값이 있으면
   배양액을 뿌릴 수 있는 땅을 candidate에 따로 저장

2. 그다음 perDay를 실행

3. perDay는 combinations를 활용해서, candidate중 R + G개의 후보지를 선택하고 selected에 저장

4. selected에서 빨간 배양액을 떨어트릴 위치를 red로 지정

5. green은 selected에서 red에 들어있지 않은 값을 전부 포함

6. backTracking(red, green)을 수행, 수행 결과는 flowers에 입력하고 ans를 최댓값으로 유지

7. red, green, flower map을 두고, red와 green의 초기 값을 각 맵에 지정

8. deque에서, x, y좌표와 색, 시간을 추출, 꽃이 피지 않은 지역은 넓어지도록 설정

9. 범위 밖인 경우와 호수(= 0), 꽃이 핀 지역은 continue

10. red와 green모두 -1로 배양액이 이동하지 않은 지역에 대해서 t+1로 설정

11. G인 경우, green의 지역이 -1인데, red_map에서 t+1로 설정되면 꽃이 핌

12. 아닌경우는 red가 -1이면 배양액이 이동

`2. 시간초과`

Python으로는 시간 초과가 발생하고, Pypy3으로 수행하면 시간 초과가 발생하지 않음.

Python3 풀이를 알고싶어서.. 백준 karinarang님의 정답 코드를 보았다..

나는 red, green, flower 맵을 전부 따로 설정했는데 이런 이유로 메모리를 많이 사용함.

그리고 dfs를 수행할 때, green과 red를 set()으로 두고, dfs수행

수행중 만약 len(g) == G and len(r) == R이면 res = bfs(g, r)을 수행하고, ans를 최댓값으로 변경한다.

만약 idx가 len(yellow)이면, 즉 배양액이 전부 사용된 만큼 idx가 커지면 return 을 수행

next = yellow[idx]로 두고, green의 배양액이 모자르면 g | {nxt} 로 set에 추가, 반대는 r | {nxt}로 set에 추가하는 형식

bfs코드르 보면 v를 전부 [0]으로 둔 맵으로 설정하고, 호수인 부분을 전부 1로 설정

그리고 deque에 (i, j, 2 or 3)을 입력한다.
2의 경우는 green, 3의 경우는 red이고, 이미 사용된 지역을 전부 1로 설정한다.

만약 새로 탐색한 위치의 값이 0이면 color로 설정하고 new_deque에 값을 추가
새로 탐색한 값이 다른 색이면 cnt += 1로 설정하고 꽃을 피운다.

이후, new_dq.remove를 사용해서 미리 넣은 green이나 red 배양액을 새로운 덱에서 지우고 flower로 설정한다.

모든 수행이 끝나고 new_dq에 있는 값을 확인해서 꽃이 되지 못한 배양액들을 전부 1로 설정해서 작동하지 않도록 하고 dq = new_dq를 수행
다시 while문을 돈다.

만약 더이상 new_dq가 없으면 -> 더이상 늘어날 수 없으므로 break를 수행하고 현재 flower의 개수를 return한다.
