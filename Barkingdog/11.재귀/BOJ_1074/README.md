# 백준 1074번 - Z

[문제 보러 가기](https://www.acmicpc.net/problem/1074)

## 요약

$2^N \times 2^N$ 인 2차원 배열을 Z모양으로 탐색, 왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른쪽 아래 순서대로 방문.

N > 1인 경우, 배열을 $2^{N-1} \times 2^{N-1}$ 으로 4등분 한 후에 재귀적으로 순서대로 방문한다.

N이 주어졌을 때, r행 c열을 몇 번째로 방문하는지 출력하는 프로그램을 작성

## 핵심 규칙

>입력
>> 첫째 줄에 정수 N, r, c가 주어진다.

>출력
>> r행 c열을 몇 번째로 방문했는지 출력한다.

## 예제 입출력

입력 및 출력 예시는 [문제 링크](https://www.acmicpc.net/problem/1074) 참고.

### 문제풀이

`1. 설계`

- r행 c열을 몇 번째로 방문했는지 출력 -> 처음에 map설정을 전부 0으로 두고
새로운 값을 추가하면서 방문 순서를 초기화

`2. 메모리 초과`

이유는
```Text
side = 2 ** n
map = [[0] * side for _ in range(side)]
```
위의 코드 때문, n이 15까지 커질 수 있는데, 이 경우 map의 범위가 너무 넓음

map을 사용하지 않고도 풀 수 있도록 설정

`3. 시간 초과`

기존 설정이 map을 전체 확인하면서 모든 값을 변경시키는 형태였으므로
필요없는 지역의 값까지 모두 바꿔 시간이 너무 오래 걸리는 문제

> 분할 정복
>> 필요한 위치의 값만 계산하도록 변경

2 3 1을 넣은 결과를 보면 정답은 11

전체 정사각형을 4등분해서 side를 2로 area를 side의 제곱인 4로 설정

특정 사분면의 경우 side와 r, c 의 관계가 생기므로 이를 사용해서 if 문으로 분절

왼쪽 위는 0 area를 더하고, 오른쪽 위는 1
왼쪽 아래는 2, 오른쪽 아래는 3 area를 더한다.

11의 경우를 보면, 왼쪽아래이므로 2 * 4를 더하고, 2 * 2크기의 정사각형에서 보면, 오른쪽 아래 사분면이므로 3 * 1을 더해서
8 + 3으로 11이 나온다.